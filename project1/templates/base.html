{% load static %}
<!DOCTYPE html>
<html lang="en" data-bs-theme="{{ THEME }}">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link rel="apple-touch-icon" sizes="76x76" href="{% static 'img/apple-icon.png' %}" />
    <link rel="icon" type="image/png" href="{% static 'img/favicon.png' %}" />
    <title>
      {% block title %}
        {{ SITE_LONG_NAME }}
      {% endblock %}
    </title>

    <!-- Fonts and icons -->
    <link href="https://fonts.googleapis.com/css?family=Inter:300,400,500,600,700,800" rel="stylesheet" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <!-- CSS Files -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <!-- Custom CSS -->
    <link href="{% static SITE.THEME_CSS %}" rel="stylesheet" />

    {% block extra_css %}

    {% endblock %}
  </head>

  <body>
    <!-- Navbar -->
    {% include 'navbar.html' %}
    <!-- End Navbar -->
    {% block extra_js %}

    {% endblock %}
    <!-- Main Content -->
{% if messages %}
  <div class="container mt-3">
    {% for message in messages %}
      <div class="alert alert-{{ message.tags|default:'info' }} alert-dismissible fade show"
           role="alert" data-autoclose="true">
        {{ message }}
        <button type="button" class="btn-close btn-close-sm" data-bs-dismiss="alert" aria-label="Close"></button>
      </div>
    {% endfor %}
  </div>
{% endif %}
    <main class="container py-5">
      {% block content %}

      {% endblock %}
    </main>

    <!-- Footer -->
    {% include 'footer.html' %}
    <!-- End Footer -->

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // Theme toggle functionality
      document.addEventListener('DOMContentLoaded', function () {
        const themeToggle = document.getElementById('themeToggle')
        const htmlElement = document.documentElement
        const themeIcon = themeToggle.querySelector('i')

        // Check for saved theme preference or use device preference
        const savedTheme = localStorage.getItem('theme')
        if (savedTheme) {
          htmlElement.setAttribute('data-bs-theme', savedTheme)
          updateIcon(savedTheme)
        } else {
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
          const initialTheme = prefersDark ? 'dark' : 'light'
          htmlElement.setAttribute('data-bs-theme', initialTheme)
          updateIcon(initialTheme)
        }

        // Toggle theme when button is clicked
        themeToggle.addEventListener('click', () => {
          const currentTheme = htmlElement.getAttribute('data-bs-theme')
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark'

          htmlElement.setAttribute('data-bs-theme', newTheme)
          localStorage.setItem('theme', newTheme)

          updateIcon(newTheme)
        })

        // Update icon based on current theme
        function updateIcon(theme) {
          if (theme === 'dark') {
            themeIcon.className = 'fa-solid fa-moon'
          } else {
            themeIcon.className = 'fa-solid fa-sun'
          }
        }
      })
      document.addEventListener('DOMContentLoaded', function () {
  // Auto-close Bootstrap alerts after 5 seconds
  document.querySelectorAll('.alert.alert-dismissible[data-autoclose]').forEach(function (el) {
    setTimeout(function () {
      try {
        // If Bootstrap JS is available, use its API
        if (window.bootstrap && bootstrap.Alert) {
          const instance = bootstrap.Alert.getOrCreateInstance(el);
          instance.close();
        } else {
          // Fallback: remove element gracefully
          el.classList.remove('show');
          el.addEventListener('transitionend', () => el.remove(), { once: true });
          setTimeout(() => el.remove(), 500); // safety removal
        }
      } catch (e) {
        el.remove();
      }
    }, 5000);
  });
});
    </script>

    <script type="module">
    // -----------------------------
    // Global wallet state & helpers
    // -----------------------------
    let provider, selectedAddress;
    const IS_USER_AUTH = {{ user.is_authenticated|yesno:"true,false" }};

    // Map EVM chainId -> key you store
    const CHAIN_MAP = {
      "0x1": "eth",
      "0x89": "polygon",
      "0x38": "bsc",
      // add more as needed
    };

    // LocalStorage keys
    const LS_ADDR = "wallet:addr";
    const LS_LINKED = "wallet:linked";

    function shortAddr(a) { return a ? a.slice(0, 6) + "…" + a.slice(-4) : ""; }

    function getCookie(name) {
      const m = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
      return m ? m.pop() : "";
    }

    function toHexMessage(str) {
      const bytes = new TextEncoder().encode(str);
      let hex = "0x";
      for (const b of bytes) hex += b.toString(16).padStart(2, "0");
      return hex;
    }

    function saveWallet(addr) {
      localStorage.setItem(LS_ADDR, addr || "");
      localStorage.setItem(LS_LINKED, "true"); // set true once verify succeeds
    }

    function markUnlinked() {
      localStorage.setItem(LS_LINKED, "false");
    }

    function clearWallet() {
      localStorage.removeItem(LS_ADDR);
      localStorage.removeItem(LS_LINKED);
    }

    function paintConnectedUI() {
      document.getElementById("btnConnect")?.classList.add("d-none");
      document.getElementById("btnDisconnect")?.classList.remove("d-none");
      const badge = document.getElementById("walletBadge");
      if (badge) { badge.classList.remove("d-none"); badge.innerText = shortAddr(selectedAddress); }
    }

    function paintDisconnectedUI() {
      document.getElementById("btnConnect")?.classList.remove("d-none");
      document.getElementById("btnDisconnect")?.classList.add("d-none");
      document.getElementById("walletBadge")?.classList.add("d-none");
    }

    function afterLogout() {
      paintDisconnectedUI()
      clearWallet()

      const userData = JSON.parse(document.getElementById("user-data").textContent);

      console.log('----------')
      console.log(userData)
      console.log('----------')

    }

    // -----------------------------
    // Connect / Disconnect
    // -----------------------------
    async function connectWallet() {
      try {
        if (!window.ethereum) { alert("No Ethereum provider found. Install MetaMask."); return; }
        provider = window.ethereum;
        const accs = await provider.request({ method: "eth_requestAccounts" });
        selectedAddress = accs?.[0] || null;
        if (!selectedAddress) return;
        await afterConnect();
      } catch (e) {
        console.error("connectWallet error:", e);
        alert("Wallet connection failed or was rejected.");
      }
    }

    async function afterConnect() {
      paintConnectedUI();

      // Expose + event
      window.selectedAddress = selectedAddress;
      window.dispatchEvent(new CustomEvent("wallet:connected", { detail: { address: selectedAddress } }));

      // Sign-in-with-wallet (writes to DB on success)
      const ok = await signLogin();
      if (ok) saveWallet(selectedAddress);
    }

    function disconnectWallet() {
      selectedAddress = null;
      provider = null;
      paintDisconnectedUI();
      window.selectedAddress = null;
      window.dispatchEvent(new CustomEvent("wallet:disconnected"));
      clearWallet();
    }

    // -----------------------------
    // Rehydrate on page load
    // -----------------------------
    async function rehydrateWallet() {
      if (!window.ethereum) return;
      provider = window.ethereum;

      // Prefer MetaMask's active account
      const accounts = await provider.request({ method: "eth_accounts" });
      const mmAddr = accounts?.[0] || null;
      const storedAddr = localStorage.getItem(LS_ADDR) || "";
      const candidate = mmAddr || storedAddr;

      if (!candidate) return; // nothing to restore

      selectedAddress = candidate;
      paintConnectedUI();

      // Optionally check if session is already linked
      try {
        const s = await fetch("/api/wallet/status/", { credentials: "same-origin" });
        if (s.ok) {
          const { linked } = await s.json();
          if (!linked) {
            // We won't auto-prompt signature here; show as connected but "needs relink"
            markUnlinked();
            window.dispatchEvent(new CustomEvent("wallet:needs-relink", { detail: { address: selectedAddress } }));
          } else {
            localStorage.setItem(LS_LINKED, "true");
          }
        } else {
          // No status endpoint — do nothing; rely on local flag
        }
      } catch {
        // Silent failure is fine – keep UI connected.
      }
    }

    // -----------------------------
    // Challenge/verify (SIW)
    // -----------------------------
    async function signLogin() {
      try {
        // 1) Challenge
        const resp = await fetch("/api/wallet/challenge/", { credentials: "same-origin" });
        const ctype = resp.headers.get("content-type") || "";
        if (resp.redirected || !ctype.includes("application/json")) {
          alert("Please log in to the site, then click Connect again.");
          return false;
        }
        const { message } = await resp.json();

        // 2) Ensure currently active account matches our selection
        const active = (await provider.request({ method: "eth_accounts" }))[0];
        if (!active || active.toLowerCase() !== selectedAddress.toLowerCase()) {
          alert("Active wallet account changed. Please reconnect.");
          return false;
        }

        // 3) Sign
        const signature = await provider.request({
          method: "personal_sign",
          params: [message, selectedAddress],
        });

        // 4) Chain key (safe catch)
        let chainKey = "eth";
        try {
          const chainId = await provider.request({ method: "eth_chainId" });
          chainKey = CHAIN_MAP[chainId] || "eth";
        } catch {
          // ignore
        }

        // 5) Verify (DB write)
        const form = new FormData();
        form.append("address", selectedAddress);
        form.append("signature", signature);
        form.append("message", message);
        form.append("chain", chainKey);   // optional now, future-proof
        form.append("scheme", "eip191");  // personal_sign

        const csrftoken = getCookie("csrftoken");
        const verifyResp = await fetch("/api/wallet/verify/", {
          method: "POST",
          body: form,
          credentials: "same-origin",
          headers: { "X-CSRFToken": csrftoken },
        });

        if (!verifyResp.ok) {
          const txt = await verifyResp.text();
          console.error("verify failed:", txt);
          alert("Wallet verify failed: " + txt);
          markUnlinked();
          return false;
        }

        // UI feedback
        const badge = document.getElementById("walletBadge");
        if (badge) {
          badge.classList.remove("d-none");
          badge.innerText = "Wallet linked: " + shortAddr(selectedAddress);
        }
        localStorage.setItem(LS_LINKED, "true");
        return true;
      } catch (e) {
        console.error("signLogin error:", e);
        alert("Signing was cancelled or failed.");
        markUnlinked();
        return false;
      }
    }

    // -----------------------------
    // Review signing (no reload)
    // -----------------------------
    async function signReview(reviewId) {
      if (!provider || !selectedAddress) { return alert("Connect wallet first."); }

      // 1) Get digest
      const resp = await fetch(`/api/reviews/${reviewId}/digest/`, { credentials: "same-origin" });
      if (!resp.ok) { alert("Digest endpoint missing or failed."); return; }
      const { digest } = await resp.json();

      // 2) Sign digest
      const signature = await provider.request({
        method: "personal_sign",
        params: [digest, selectedAddress],
      });

      // 3) Send signature
      const form = new FormData();
      form.append("address", selectedAddress);
      form.append("signature", signature);

      const csrftoken = getCookie("csrftoken");
      const r = await fetch(`/api/reviews/${reviewId}/sign/`, {
        method: "POST",
        body: form,
        credentials: "same-origin",
        headers: { "X-CSRFToken": csrftoken },
      });

      if (!r.ok) {
        const txt = await r.text();
        alert("Failed to sign review: " + txt);
        return;
      }

      let payload = {};
      try { payload = await r.json(); } catch { /* no-op */ }
      console.log("Review signed:", payload);

      // 4) Optimistic UI updates (no full reload)
      const root = document.querySelector(`[data-review-id="${reviewId}"]`);
      const btn = root?.querySelector(".js-sign-btn") || document.getElementById(`sign-btn-${reviewId}`);
      if (btn) {
        btn.classList.add("btn-success");
        btn.classList.remove("btn-outline-primary");
        btn.disabled = true;
        btn.innerHTML = `<i class="fa-solid fa-check me-1"></i> Signed`;
      }
      const signedChip = root?.querySelector(".js-signed-chip");
      if (signedChip) {
        signedChip.classList.remove("d-none");
        signedChip.textContent = "Signature saved";
      }
    }

    // Expose if you call from onclick in templates
    window.signReview = signReview;

    // -----------------------------
    // Provider events
    // -----------------------------
    if (window.ethereum) {
      window.ethereum.on?.("accountsChanged", (accs) => {
        if (!accs?.length) { disconnectWallet(); return; }
        selectedAddress = accs[0];
        saveWallet(selectedAddress);
        paintConnectedUI();
        window.dispatchEvent(new CustomEvent("wallet:account-changed", { detail: { address: selectedAddress } }));
        // Tip: show a small toast "Account changed; re-link if needed."
      });

      window.ethereum.on?.("chainChanged", (_chainId) => {
        window.dispatchEvent(new CustomEvent("wallet:chain-changed", { detail: { chainId: _chainId } }));
        // Avoid auto-sign here; only update chips/badges if you show chain.
      });
    }

    // -----------------------------
    // Wire buttons + rehydrate
    // -----------------------------
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("btnConnect")?.addEventListener("click", connectWallet);
      document.getElementById("btnDisconnect")?.addEventListener("click", disconnectWallet);
      if (IS_USER_AUTH) rehydrateWallet(); // restore on every page load (silent)
      document.getElementById("logoutbtn")?.addEventListener("click", afterLogout)
    });
  </script>

    <script>
    (function () {
      const input = document.getElementById("{{ form.wallet_address.id_for_label }}");

      function prefill(addr) {
        if (!input) return;
        if (!input.value || input.value.trim() === "") {
          input.value = addr;
        }
      }

      // If already connected before landing here
      if (window.selectedAddress) prefill(window.selectedAddress);

      // React to a fresh connect
      window.addEventListener("wallet:connected", (ev) => prefill(ev.detail.address));

      // Optional: clear on disconnect
      // window.addEventListener("wallet:disconnected", () => { if (input) input.value = ""; });
    })();
  </script>
  </body>
</html>
